---
description: 
globs: 
alwaysApply: false
---
# IPC Handler Implementation Guide

This guide provides complete instructions for adding new IPC handlers with proper lifecycle management and security.

## Architecture Overview

- **`src/main/ipc/index.ts`**: [index.ts](mdc:src/main/ipc/index.ts) - Central registration/cleanup orchestration
- **`src/main/ipc/utils.ts`**: [utils.ts](mdc:src/main/ipc/utils.ts) - Security validation utilities
- **`src/shared/ipc-events.ts`**: [ipc-events.ts](mdc:src/shared/ipc-events.ts) - Centralized event name definitions
- **`src/preload/index.ts`**: [preload.ts](mdc:src/preload/index.ts) - Renderer API exposure

## Step-by-Step Implementation

### 1. Define IPC Event Constants
Add your event name to `IpcEvents` enum in [ipc-events.ts](mdc:src/shared/ipc-events.ts):
```typescript
export enum IpcEvents {
  OPEN_SETTINGS = 'open-settings',
  YOUR_NEW_EVENT = 'your-new-event' // Use kebab-case
}
```

### 2. Create Handler Implementation
Create `src/main/ipc/your-feature.ts` with this exact structure:
```typescript
import { ipcMain } from 'electron'
import { validateSender } from './utils'
import { IpcEvents } from '../../shared/ipc-events'

export function registerYourFeatureHandler(): () => void {
  const handleYourEvent = (event: Electron.IpcMainEvent, ...args: unknown[]) => {
    // ALWAYS validate sender first
    if (!validateSender(event.senderFrame)) {
      console.warn('Invalid sender for your-event')
      return
    }
    
    try {
      // Your implementation logic here
      // Use event.reply() for responses
      event.reply(`${IpcEvents.YOUR_NEW_EVENT}-response`, result)
    } catch (error) {
      console.error('Error in your-event handler:', error)
      event.reply(`${IpcEvents.YOUR_NEW_EVENT}-error`, error.message)
    }
  }

  // Register the handler
  ipcMain.on(IpcEvents.YOUR_NEW_EVENT, handleYourEvent)
  
  // Return cleanup function (CRITICAL for memory management)
  return () => {
    ipcMain.removeListener(IpcEvents.YOUR_NEW_EVENT, handleYourEvent)
  }
}
```

### 3. Register in Central Handler
Import and register in [index.ts](mdc:src/main/ipc/index.ts):
```typescript
import { registerYourFeatureHandler } from './your-feature'

export function initializeGlobalIpcHandlers(): void {
  cleanupGlobalIpcHandlers()
  
  handlerCleanups.push(
    registerYourFeatureHandler() // Add here
  )
}
```

### 4. Expose API in Preload
Add to `customApi` object in [preload/index.ts](mdc:src/preload/index.ts):
```typescript
const customApi = {
  // Existing APIs...
  
  // Your new API
  yourFeature: {
    invoke: (...args: unknown[]) => ipcRenderer.invoke(IpcEvents.YOUR_NEW_EVENT, ...args),
    send: (...args: unknown[]) => ipcRenderer.send(IpcEvents.YOUR_NEW_EVENT, ...args),
    on: (callback: (...args: unknown[]) => void) => {
      ipcRenderer.on(`${IpcEvents.YOUR_NEW_EVENT}-response`, (_, ...args) => callback(...args))
      return () => ipcRenderer.removeAllListeners(`${IpcEvents.YOUR_NEW_EVENT}-response`)
    }
  }
}
```

### 5. Add TypeScript Definitions
Update [index.d.ts](mdc:src/preload/index.d.ts):
```typescript
declare global {
  interface Window {
    api: ElectronAPI & {
      // Existing APIs...
      
      yourFeature: {
        invoke: (...args: unknown[]) => Promise<unknown>
        send: (...args: unknown[]) => void
        on: (callback: (...args: unknown[]) => void) => () => void
      }
    }
  }
}
```

## Required Patterns

### Security First
- **ALWAYS** call `validateSender(event.senderFrame)` first
- Reject invalid senders with warning logs
- Never trust renderer-provided data without validation

### Error Handling
- Wrap all handler logic in try-catch blocks
- Log errors with descriptive context
- Send error responses back to renderer when appropriate

### Memory Management
- **MUST** return cleanup functions from register functions
- Use named handler functions (not anonymous) for proper cleanup
- Test cleanup by checking `ipcMain.listenerCount(eventName)` equals 0 after cleanup

### Communication Patterns
- Use `ipcRenderer.invoke()` / `ipcMain.handle()` for request-response
- Use `ipcRenderer.send()` / `ipcMain.on()` for fire-and-forget
- Use consistent response/error event naming: `${eventName}-response` / `${eventName}-error`

### Testing Your Implementation
1. Check handler registration: `console.log(ipcMain.listenerCount(IpcEvents.YOUR_NEW_EVENT))`
2. Test cleanup: Call cleanup function, verify listener count is 0
3. Verify security: Test with invalid sender (should be rejected)
4. Test error cases: Ensure errors are caught and logged properly
